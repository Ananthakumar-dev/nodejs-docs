We use spawn to run processes to run applications.

So right now you have a whole bunch of applications installed on your machine.

And you can run all of them using this spawn.

________________________________________________________________________________

const {spawn} = require('child_process');

const subprocess = spawn('ls')
subprocess.stdout.on('data', (data) => {
    console.log(data.toString('utf-8'));
})

here if we execute this it working. it prints output of ls command that we did in command line.

but it does not works for
const subprocess = spawn('ll')
const subprocess = spawn('disown')
const subprocess = spawn('bash', ['./scripts.sh'])
this kind of operations.

And initiate child processes with arguments is 
const subprocess = spawn('ls', ['-l'])
This also not works.

So What can we specify here and what can't we specify here. here means argument of spawn method. it throws the error entity not found ENOENT

________________________________________________________________________________

But,

const {exec} = require('child_process')

exec('ls -l', (error, stdout, stderr) => {
    if(error) {
        console.error(error)
        return;
    }

    console.log(stdout)
    console.log(stderr)
})

exec('disown', ...)

but this exec is working. but some error is occured. it throws like command not found.
________________________________________________________________________________

And if we look at
const subprocess = spawn("echo", ["Some string", "|", "tr", " ", "\n"]);

if we execute this it prints "Some string | tr" as a string.

so what is happening right now is that echo is being run, but the rest of them are just being passed as its argument.

But the above same echo thing works with exec function.

________________________________________________________________________________

So here spawn and exec are working based on unix concepts.
Now the main difference between spawn and exec is that exec is going to take this command, and it's going to run it in a shell.

But here, this spawn, it's not going it doesn't have to do anything with a shell.

It's just going to start a new process.

The thing we are writing in exec function is should be a shell script.
But spawn function used to execute the unix executable file. 

So in your first arguments and spawn you have to specify a Unix executable file.

NodeJS is going to look in the path to find that thing.

So just like the bash would do it and the spawn doesn't care about aliases or functions or built in functions, the only thing that it's going to look for is all the stuff that we have in the path.

So the spawn process doesn't care about aliases or functions or built in functions.

It just simply doesn't care, because its whole purpose of spawn is to start new processes, to start new Unix executable files.

So the only thing that the spawn function is going to look for is right here in the path.

________________________________________________________________________________
But what exactly is a child process in Unix?

Now in Unix on top of your kernel.

We saw this previously that you have opened up many different processes.

So you've got these processes opened up in your operating system.

For example bash is a process node is a process, Google Chrome and hundreds of others.

Now each process in Unix has a process ID or a PID.

So Unix the kernel, when it's about to start a new process, it will assign a unique ID to that process

so that we can identify that process.

And this ID this PID is unique to only this process.

So now we can diagnose it if we want to kill it later on.

We know how to kill it.

We say kill in our terminal.

We specify the PID and then we can kill the process.

So each process has a PID associated with it.

Now another thing that each process has is also a parent process ID or just PID.

Now the parent process ID is the ID of the process that spawns this process.

In Unix, all processes have a parent process and the parents of all the processes.

So if you just take a look at each process, you see that that process has a parent.

And if we go into that process you see that that process has another parent.

And if we just keep going at the end of the line, you're going to find a process that has ID zero. And that's the kernel itself.

So each process has a parent process except the kernel.

It's part of the kernel that's responsible for opening up some of the processes.

And that's the main that's the main parent of all the other processes.

So technically all the processes that you have in your operating system, they are all child processes.

And each process has this ability to start other processes.

So all of these processes are sitting inside of your Ram.

You might have eight gigabytes of Ram, 1632 whatever it is, all these processes are occupying that storage.

for ex: shell initiate node process. so here parent process is shell and child_process is node. 

So this is what we mean by a child process.

It's just a process that has been opened up by another process and all the processes that you have.

checking the process id in shell: echo $$ & echo $PPID
checking the process id in node: process.pid & process.ppid to check the parent process id.

we can pass the arguments when initiate child_process and get it using process.argv in node.